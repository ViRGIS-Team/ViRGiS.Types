// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

const uint TriangleCount;

StructuredBuffer<uint3> Triangles;

RWStructuredBuffer<uint> completeFlag;

RWStructuredBuffer<uint> Colors;

[numthreads(16,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    completeFlag[id.x]=0;
    if (id.x >= TriangleCount) return;

    const uint3 tri = Triangles[id.x];
    const uint a = Colors[tri[0]];
    const uint b = Colors[tri[1]];
    const uint c = Colors[tri[2]];
    const uint3 d = {a,b,c};

    if ( a == 0 && b == 0 && c == 0 ) return;
    
    if ( a != b && b != c && c != a ) return;

    if ( a == 7 || b == 7 || c == 7 ) {
        completeFlag[id.x] += 1;
        InterlockedCompareStore(Colors[tri[0]], a, 0);
        InterlockedCompareStore(Colors[tri[1]], b, 0);
        InterlockedCompareStore(Colors[tri[2]], c, 0);
        return;
    }

    for (uint i = 0; i < 3; i++)
    {
        uint j = (i + 1) % 3;
        uint k = (i + 2) % 3; 
        if (
                d[i] == 0 ||
                d[i] == d[j] ||
                d[i] == d[k]
            )
        {
            completeFlag[id.x] += 1;
            for (uint nc = max(1,d[i]); nc < 8; nc++)
            {
                if (nc == 6 && max(d[j], d[k]) == 6) {
                    if(d[j] == 6) {
                        d[j] == 1;
                    } else {
                        d[k] == 1;
                    }
                }
                if ( nc != Colors[tri[0]] &&
                     nc != Colors[tri[1]] &&
                     nc != Colors[tri[2]]
                   )
                {
                    InterlockedCompareStore(Colors[tri[i]],d[i],nc);
                    break;
                }
            }
        }
    }
}